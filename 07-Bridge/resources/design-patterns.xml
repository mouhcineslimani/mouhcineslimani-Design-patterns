<?xml version="1.0" encoding="UTF-8"?>
<design-patterns>
	<design-pattern id="1">
		<name>Singleton</name>
		<category>Creational</category>
		<intent>Ensure a class only has one instance, and provide a global
			point of access to it.
		</intent>
	</design-pattern>
	<design-pattern id="2">
		<name>Prototype</name>
		<category>Creational</category>
		<intent>Specify the kinds of objects to create using a prototypical
			instance, and create new objects
			by copying this prototype.
		</intent>
	</design-pattern>
	<design-pattern id="3">
		<name>Factory Method</name>
		<category>Creational</category>
		<intent>Define an interface for creating an object, but let subclasses
			decide which class to
			instantiate. Factory Method lets a class defer
			instantiation to subclasses.
		</intent>
	</design-pattern>
	<design-pattern id="4">
		<name>Abstract Factory</name>
		<category>Creational</category>
		<intent>Provide an interface for creating families of related or
			dependent objects without specifying
			their concrete classes.
		</intent>
	</design-pattern>
	<design-pattern id="5">
		<name>Builder</name>
		<category>Creational</category>
		<intent>Separate the construction of a complex object from its
			representation so that the same
			construction process can create
			different representations.
		</intent>
	</design-pattern>
	<design-pattern id="6">
		<name>Adapter</name>
		<category>Structural</category>
		<intent>Convert the interface of a class into another interface
			clients expect. Adapter lets classes
			work together that couldn't
			otherwise because of incompatible interfaces.
		</intent>
	</design-pattern>
	<design-pattern id="7">
		<name>Bridge</name>
		<category>Structural</category>
		<intent>Decouple an abstraction from its implementation so that the
			two can vary independently.
		</intent>
	</design-pattern>
	<design-pattern id="8">
		<name>Composite</name>
		<category>Structural</category>
		<intent>Compose objects into tree structures to represent part-whole
			hierarchies. Composite lets
			clients treat individual objects and
			compositions of objects uniformly.
		</intent>
	</design-pattern>
	<design-pattern id="9">
		<name>Decorator</name>
		<category>Structural</category>
		<intent>Attach additional responsibilities to an object dynamically.
			Decorators provide a flexible
			alternative to subclassing for extending
			functionality.
		</intent>
	</design-pattern>
	<design-pattern id="10">
		<name>Facade</name>
		<category>Structural</category>
		<intent>Provide a unified interface to a set of interfaces in a
			subsystem. Facade defines a higher level interface that makes the
			subsystem easier to use.
		</intent>
	</design-pattern>
	<design-pattern id="11">
		<name>Flyweight</name>
		<category>Structural</category>
		<intent>Use sharing to support large numbers of fine-grained objects
			efficiently.
		</intent>
	</design-pattern>
	<design-pattern id="12">
		<name>Proxy</name>
		<category>Structural</category>
		<intent>Provide a surrogate or placeholder for another object to
			control access to it.
		</intent>
	</design-pattern>
	<design-pattern id="13">
		<name>Chain of Responsibility
		</name>
		<category>Behavioral</category>
		<intent>Avoid coupling the sender of a request to its receiver by
			giving more than one object a
			chance to handle the request. Chain the
			receiving objects and pass the
			request along the
			chain until an object
			handles it.
		</intent>
	</design-pattern>
	<design-pattern id="14">
		<name>Command</name>
		<category>Behavioral</category>
		<intent>Encapsulate a request as an object, thereby letting you
			parameterize clients with different
			requests, queue or log requests,
			and support undoable operations.
		</intent>
	</design-pattern>
	<design-pattern id="15">
		<name>Interpreter</name>
		<category>Behavioral</category>
		<intent>Given a language, define a represention for its grammar along
			with an interpreter that uses
			the representation to interpret
			sentences in the language.
		</intent>
	</design-pattern>
	<design-pattern id="16">
		<name>Iterator</name>
		<category>Behavioral</category>
		<intent>Provide a way to access the elements of an aggregate object
			sequentially without exposing
			its underlying representation.
		</intent>
	</design-pattern>
	<design-pattern id="17">
		<name>Mediator</name>
		<category>Behavioral</category>
		<intent>Define an object that encapsulates how a set of objects
			interact. Mediator promotes loose
			coupling by keeping objects from
			referring to each other explicitly, and it
			lets you vary their
			interaction independently.
		</intent>
	</design-pattern>
	<design-pattern id="18">
		<name>Memento
		</name>
		<category>Behavioral</category>
		<intent>Without violating encapsulation, capture and externalize an
			object's internal state so that the
			object can be restored to this
			state later.
		</intent>
	</design-pattern>
	<design-pattern id="19">
		<name>Observer</name>
		<category>Behavioral</category>
		<intent>Define a one-to-many dependency between objects so that when
			one object changes state,
			all its dependents are notified and updated
			automatically.
		</intent>
	</design-pattern>
	<design-pattern id="20">
		<name>State	</name>
		<category>Behavioral</category>
		<intent>Allow an object to alter its behavior when its internal state
			changes. The object will appear to
			change its class.
		</intent>
	</design-pattern>
	<design-pattern id="21">
		<name>Strategy</name>
		<category>Behavioral</category>
		<intent>Define a family of algorithms, encapsulate each one, and make
			them interchangeable.
			Strategy lets the algorithm vary independently from clients that use it.
		</intent>
	</design-pattern>
	<design-pattern id="22">
		<name>Template Method</name>
		<category>Behavioral</category>
		<intent>Define the skeleton of an algorithm in an operation, deferring
			some steps to subclasses.
			Template Method lets subclasses redefine certain steps of an algorithm
			without changing the
			algorithm's structure
		</intent>
	</design-pattern>
	<design-pattern id="23">
		<name>Visitor</name>
		<category>Behavioral</category>
		<intent>Represent an operation to be performed on the elements of an
			object structure. Visitor lets
			you define a new operation without changing the classes of the elements
			on which it
			operates.
		</intent>
	</design-pattern>
</design-patterns>